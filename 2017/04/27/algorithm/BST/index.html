<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.3.4 -->

    <!-- Title -->
    
    <title>
        
            我的算法之路 -- BST二叉搜索树 | 
        
        Mr.Metro
    </title>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">
    
    
    
    
    
    
        <link rel="dns-prefetch" href="https://busuanzi.ibruce.info"/>
    

    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="miccall">
    <meta name="description" content="Blog of miccall is records about my work">
    <meta name="keywords" content="miccall,Algorithm">
    
    

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/logo_miccall.png">
    <link rel="icon" sizes="192x192" href="/img/logo_miccall.png">
    <link rel="apple-touch-icon" href="/img/logo_miccall.png">

    <!--iOS -->
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Mr.Metro">

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://miccall.tech">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="我的算法之路 -- BST二叉搜索树 | Mr.Metro">
    <meta property="og:description" content="Blog of miccall is records about my work">
    <meta property="og:article:tag" content="Algorithm"> 

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>!function(){var e="http://"+location.host+"/combo?combo=";window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}},lsloader.removeLS=function(e){try{localStorage.removeItem(e)}catch(e){}},lsloader.setLS=function(e,t){try{localStorage.setItem(e,t)}catch(e){}},lsloader.getLS=function(e){var t="";try{t=localStorage.getItem(e)}catch(e){t=""}return t},lsloader.load=function(e,t,s){s=s||function(){};var n;if(n=this.getLS(e),!/\/\*codestartv1\*\//.test(n))return this.removeLS(e),void this.requestResource(e,t,s);if(n){var a=n.split("/*codestartv1*/")[0];if(a!=t)return console.log("reload:"+t),this.removeLS(e),void this.requestResource(e,t,s);n=n.split("/*codestartv1*/")[1],/\.js?.+$/.test(a)?(this.jsRunSequence.push({name:e,code:n}),this.runjs(t,e,n)):(document.getElementById(e).appendChild(document.createTextNode(n)),s())}else this.requestResource(e,t,s)},lsloader.requestResource=function(e,t,s){var n=this;/\.js?.+$/.test(t)?this.iojs(t,e,function(e,t,s){n.setLS(t,e+"/*codestartv1*/"+s),n.runjs(e,t,s)}):/\.css?.+$/.test(t)&&this.iocss(t,e,function(s){document.getElementById(e).appendChild(document.createTextNode(s)),n.setLS(e,t+"/*codestartv1*/"+s)},s)},lsloader.iojs=function(e,t,s){var n=this;n.jsRunSequence.push({name:t,code:""});try{var a=new XMLHttpRequest;a.open("get",e,!0),a.onreadystatechange=function(){if(4==a.readyState){if((a.status>=200&&a.status<300||304==a.status)&&""!=a.response)return void s(e,t,a.response);n.jsfallback(e,t)}},a.send(null)}catch(s){n.jsfallback(e,t)}},lsloader.iocss=function(e,t,s,n){var a=this;try{var u=new XMLHttpRequest;u.open("get",e,!0),u.onreadystatechange=function(){if(4==u.readyState){if((u.status>=200&&u.status<300||304==u.status)&&""!=u.response)return s(u.response),void n();a.cssfallback(e,t,n)}},u.send(null)}catch(s){a.cssfallback(e,t,n)}},lsloader.iofonts=function(e,t,s,n){var a=this;try{var u=new XMLHttpRequest;u.open("get",e,!0),u.onreadystatechange=function(){if(4==u.readyState){if((u.status>=200&&u.status<300||304==u.status)&&""!=u.response)return s(u.response),void n();a.cssfallback(e,t,n)}},u.send(null)}catch(s){a.cssfallback(e,t,n)}},lsloader.runjs=function(e,t,s){if(t&&s)for(var n in this.jsRunSequence)this.jsRunSequence[n].name==t&&(this.jsRunSequence[n].code=s);if(this.jsRunSequence[0]&&this.jsRunSequence[0].code&&"failed"!=this.jsRunSequence[0].status){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code)),a.type="text/javascript",document.getElementsByTagName("head")[0].appendChild(a),this.jsRunSequence.shift(),this.jsRunSequence.length>0&&this.runjs()}else if(this.jsRunSequence[0]&&"failed"==this.jsRunSequence[0].status){var u=this,a=document.createElement("script");a.src=this.jsRunSequence[0].path,a.type="text/javascript",this.jsRunSequence[0].status="loading",a.onload=function(){u.jsRunSequence.shift(),u.jsRunSequence.length>0&&u.runjs()},document.body.appendChild(a)}},lsloader.tagLoad=function(e,t){this.jsRunSequence.push({name:t,code:"",path:e,status:"failed"}),this.runjs()},lsloader.jsfallback=function(e,t){if(!this.jsnamemap[t]){this.jsnamemap[t]=t;for(var s in this.jsRunSequence)this.jsRunSequence[s].name==t&&(this.jsRunSequence[s].code="",this.jsRunSequence[s].status="failed",this.jsRunSequence[s].path=e);this.runjs()}},lsloader.cssfallback=function(e,t,s){if(!this.cssnamemap[t]){this.cssnamemap[t]=1;var n=document.createElement("link");n.type="text/css",n.href=e,n.rel="stylesheet",n.onload=n.onerror=s;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(n,a)}},lsloader.runInlineScript=function(e,t){var s=document.getElementById(t).innerText;this.jsRunSequence.push({name:e,code:s}),this.runjs()},lsloader.loadCombo=function(t){var s="",n={};for(var a in t){var u=this.getLS(t[a].name);if(u)var o=u.split("/*codestartv1*/")[0],c=u.split("/*codestartv1*/")[1];else var o="";o==t[a].path?this.jsRunSequence.push({name:t[a].name,code:c,path:t[a].path}):(this.jsRunSequence.push({name:t[a].name,code:null,path:t[a].path,status:"comboloading"}),n[t[a].name]=!0,s+=(""==s?"":";")+t[a].path)}var i=this;if(s){var r=new XMLHttpRequest;r.open("get",e+s,!0),r.onreadystatechange=function(){if(4==r.readyState)if(r.status>=200&&r.status<300||304==r.status){if(""!=r.response)return void i.runCombo(r.response,n)}else{for(var e in i.jsRunSequence)n[i.jsRunSequence[e].name]&&(i.jsRunSequence[e].status="failed");i.runjs()}},r.send(null)}this.runjs()},lsloader.runCombo=function(e,t){e=e.split("/*combojs*/"),e.shift();for(var s in this.jsRunSequence)t[this.jsRunSequence[s].name]&&e[0]&&(this.jsRunSequence[s].status="comboJS",this.jsRunSequence[s].code=e[0],this.setLS(this.jsRunSequence[s].name,this.jsRunSequence[s].path+"/*codestartv1*/"+e[0]),e.shift());this.runjs()}}();</script>

    <!-- Import CSS & jQuery -->
    
        <style id="css/material.min.css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("css/material.min.css","/css/material.min.css?fJTiM/K1J3dWIruo3pxtAw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";})</script>
        <style id="css/style.min.css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("css/style.min.css","/css/style.min.css?Vwvi0UKsWZkqwcl1aaIPhg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";})</script>
        <!-- Config CSS -->


<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
  }


    @font-face {
        font-family: 'Material Icons';
        font-style: normal;
        font-weight: 400;
        src: url(/fonts/MaterialIcons-Regular.eot);
        src: url(/fonts/MaterialIcons-Regular.woff2) format('woff2'), url(/fonts/MaterialIcons-Regular.woff) format('woff'), url(/fonts/MaterialIcons-Regular.ttf) format('truetype')
    }



    @font-face {
        font-family: 'FontAwesome';
        src: url(/fonts/fontawesome-webfont.eot?v=4.5.0);
        src: url(/fonts/fontawesome-webfont.eot?#iefix&v=4.5.0) format('embedded-opentype'), url(/fonts/fontawesome-webfont.woff2?v=4.5.0) format('woff2'), url(/fonts/fontawesome-webfont.woff?v=4.5.0) format('woff'), url(/fonts/fontawesome-webfont.ttf?v=4.5.0) format('truetype'), url(/fonts/fontawesome-webfont.svg?v=4.5.0#fontawesomeregular) format('svg');
        font-weight: 400;
        font-style: normal
    }
 

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #7EC0EE !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #7EC0EE !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #7EC0EE !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-image: url(/img/bg.png);
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


        <script>lsloader.load("js/jquery.min.js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==")</script>
        <script>lsloader.load("js/queue.min.js","/js/queue.min.js?FnfjxZSXVYqfU7c7cm3txg==")</script>
    

    

    

    <!-- Custom Head -->
    
<link rel="stylesheet" href="/css/prism-coy.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->

    <!-- Left aligned menu below button -->
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#我的算法之路-–-BST二叉搜索树"><span class="post-toc-number">1.</span> <span class="post-toc-text"> 我的算法之路 – BST二叉搜索树  </span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#Created-by-miccall-转载请注明出处"><span class="post-toc-number">1.0.0.0.0.1.</span> <span class="post-toc-text">Created by miccall   (转载请注明出处)</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二分查找-Binary-Search"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">二分查找 Binary Search</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二分搜索树-Binary-Search-Tree"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">二分搜索树  Binary Search Tree</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二分搜索树-的方法"><span class="post-toc-number">1.0.3.</span> <span class="post-toc-text">二分搜索树 的方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#插入新的节点-Insert"><span class="post-toc-number">1.0.3.1.</span> <span class="post-toc-text">插入新的节点 Insert</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#寻找节点是否存在-contain"><span class="post-toc-number">1.0.3.2.</span> <span class="post-toc-text">寻找节点是否存在 contain</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#提取值的查找-Search"><span class="post-toc-number">1.0.3.3.</span> <span class="post-toc-text">提取值的查找 Search</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#DFS-深度优先搜索"><span class="post-toc-number">1.0.3.4.</span> <span class="post-toc-text">DFS(深度优先搜索)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#前序遍历-preOrder"><span class="post-toc-number">1.0.3.4.1.</span> <span class="post-toc-text">前序遍历 preOrder</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#中序遍历-inOrder"><span class="post-toc-number">1.0.3.4.2.</span> <span class="post-toc-text">中序遍历 inOrder</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#后序遍历-postOrder"><span class="post-toc-number">1.0.3.4.3.</span> <span class="post-toc-text">后序遍历 postOrder</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#BSF-广度优先搜索-levelOrder-层次遍历"><span class="post-toc-number">1.0.3.5.</span> <span class="post-toc-text">BSF (广度优先搜索) levelOrder 层次遍历</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#寻找最大值与最小值"><span class="post-toc-number">1.0.3.6.</span> <span class="post-toc-text">寻找最大值与最小值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#移除最大值与最小值"><span class="post-toc-number">1.0.3.7.</span> <span class="post-toc-text">移除最大值与最小值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#移除任意一个值"><span class="post-toc-number">1.0.3.8.</span> <span class="post-toc-text">移除任意一个值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#析构函数"><span class="post-toc-number">1.0.3.9.</span> <span class="post-toc-text">析构函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#其他的一些知识"><span class="post-toc-number">1.0.4.</span> <span class="post-toc-text">其他的一些知识</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#BST的局限性"><span class="post-toc-number">1.0.5.</span> <span class="post-toc-text">BST的局限性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#其他递归问题"><span class="post-toc-number">1.0.6.</span> <span class="post-toc-text">其他递归问题</span></a></li></ol></li></ol></li></ol>

        <!--
        <li class="mdl-menu__item">
            Some Action
        </li>
        -->
    </ul>




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        <!-- Custom Thumbnail -->
        <div class="post_thumbnail-custom mdl-card__media mdl-color-text--grey-50" style="background-image:url(https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1492448025770&di=4947a369fb680fbc9563ce8d5f60d451&imgtype=0&src=http%3A%2F%2Fcdn.duitang.com%2Fuploads%2Fitem%2F201408%2F01%2F20140801065530_iPjAZ.png)">
    
            <p class="article-headline-p">
                我的算法之路 -- BST二叉搜索树
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/BA201701210404530018-00-000000.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>miccall</strong>
        <span>4月 27, 2017</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    
        <button id="article-functions-qrcode-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
            <i class="material-icons" role="presentation">devices other</i>
            <span class="visuallyhidden">devices other</span>
        </button>
        <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-qrcode-button">
            <li class="mdl-menu__item">在其它设备中阅读本文章</li>
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACeklEQVR42u3bQW7jMBAEQP//07sPcCx3D2nKCYqnIDIkFgNo6Obk8e9PjwceHh4eHh4eHt6X8R7xeP78832ef/7h8S+uvrpnPjc8PDy8k7w3r9rLqb9aguQzbyZazg0PDw/vPO+6GFy/svNJz5aymBseHh7el/HaDXF+NXkuHh4e3m/kXUcSr9jtYuHh4eH9Fl7xhf+Stx4x3Ja14OHh4cW89gDs5M83nO/h4eHhXfLakb/o2/Iwi31/eC4eHh7eh3nXDVVt69Ws4WAlGh5mLXh4eHibeG3MOjsem2GSUBgPDw/vLl59u+UC8OZF3/7LAR4eHt6HeclmOp/KrpLTBr54eHh453nJpjmfbhJwzEKHYWHAw8PD28rLD6KiW29diDa8wMPDwzvDm0US+Ut/djCWlwc8PDy887xdccMsyGgBeHh4eN/Am22RZ+HsK0YSNGyoe3h4eHgf4+UN923TQBvX5mA8PDy8k7x8g1s8IF6gPEoutux4eHh4R3j55GZtAfmxVltUtrUO4OHh4ZVb6llY0B5i7S0Jw3ZVPDw8vGVe29I024jPWg3axlY8PDy8M7xdN10pGPkmPikPeHh4eGd4+Xa5LQy7GhSWCgMeHh7eVl77tX8lxl1pIMi343h4eHif5rUjb8+a/X52FQ8PD+8k7xGPfNPcHqflR1/RHwAPDw/vCC+PAB7lWNmg53PAw8PDu4vXfu3P44mkGMwWq85a8PDw8I7zkhgiP/Sa3XPpAAwPDw/vJl4eH+Qlod1k12EEHh4e3gd4xct3oUkruZoExHVhwMPDw9vK29DqVLZVJUvTNh/g4eHhneH9vYGHh4eHh4eHh/cF4z9Yv0A7PbCY3AAAAABJRU5ErkJggg==">
        </ul>
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/Algorithm/">Algorithm</a>
    </ul>
    

    <!-- Share -->
    <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    
        
            <!-- Busuanzi Views -->
            <a class="post_share-link" href="#">
                <li class="mdl-menu__item">
                    <span id="busuanzi_container_page_pv">
                        <span id="busuanzi_value_page_pv"></span>&nbsp;浏览量
                    </span>
                </li>
            </a>
        
    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=我的算法之路 -- BST二叉搜索树&url=http://miccall.tech//2017/04/27/algorithm/BST/index.html&pic=&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=我的算法之路 -- BST二叉搜索树&url=http://miccall.tech//2017/04/27/algorithm/BST/index.html&via=miccall" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://miccall.tech//2017/04/27/algorithm/BST/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://miccall.tech//2017/04/27/algorithm/BST/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    
        <a class="post_share-link" href="http://connect.qq.com/widget/shareqq/index.html?site=Mr.Metro&title=我的算法之路 -- BST二叉搜索树&summary=Blog of miccall is records about my work&pics=http://miccall.tech/img/logo_miccall.png&url=http://miccall.tech/2017/04/27/algorithm/BST/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 QQ
            </li>
        </a>
    

    <!-- Share Telegram -->
    
</ul>

</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <hr>
<h1 id="我的算法之路-–-BST二叉搜索树"><a href="#我的算法之路-–-BST二叉搜索树" class="headerlink" title=" 我的算法之路 – BST二叉搜索树  "></a><strong> 我的算法之路 – BST二叉搜索树  </strong></h1><h6 id="Created-by-miccall-转载请注明出处"><a href="#Created-by-miccall-转载请注明出处" class="headerlink" title="Created by miccall   (转载请注明出处)"></a>Created by miccall   (<a href="http://miccall.tech">转载请注明出处</a>)</h6><ul>
<li><p>按理说这类文章首先应该讲一些鸡汤啊 鼓励学习什么的话    但是没有</p>
</li>
<li><p>按理说这类文章应该有一些推荐路径或者学习方法           但是没有 </p>
</li>
<li><p>按理说这个文章应该和其他的类似 讲些算法之坑            但是没有 </p>
</li>
<li><p>那这篇文章出现的意义是什么 没什么 就是我的学习之路  你爱看就看看 </p>
</li>
</ul>
<h3 id="二分查找-Binary-Search"><a href="#二分查找-Binary-Search" class="headerlink" title="二分查找 Binary Search"></a>二分查找 Binary Search</h3><ul>
<li><p>对于有序列 才能使用二分查找法 </p>
</li>
<li><p>对于有序列 先比较数组中间的元素 ‘v’ 与 我们想要查找元素的大小 </p>
</li>
<li><p>如果正好相等，那么很幸运 我们找到了这个元素 </p>
</li>
<li><p>此时 ，数组就被 ‘v’ 分成了两半 一半全部小于’v’ ，另一半则大于 ‘v’。</p>
</li>
<li><p>那么我就知道了 ，我们可以递归的在这两个分开的数组中找我们想要找的元素了。</p>
</li>
</ul>
<p><img src="http://onh0umlhz.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE01.PNG" alt="erfen"></p>
<ul>
<li>这里我给出非递归的实现方式 有兴趣的可以尝试递归的方式 或者网上一搜一大片。</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token comment" spellcheck="true">//首先我们给定有序列arr 长度n 搜索元素 target 返回他的位置 </span>
        <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
        <span class="token keyword">int</span> <span class="token function">BinarySearch</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token keyword">int</span> n <span class="token punctuation">,</span> T target<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
             <span class="token comment" spellcheck="true">//在 arr[l....r] 之中查找 target </span>
             <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token number">-1</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//区间 有边界是n-1 他是一个闭区间</span>

             <span class="token comment" spellcheck="true">//当区间还有元素时 </span>
             <span class="token keyword">while</span><span class="token punctuation">(</span> l <span class="token operator">&lt;=</span> r <span class="token punctuation">)</span> 
             <span class="token punctuation">{</span>
                 <span class="token comment" spellcheck="true">//int mid = ( l + r ) / 2 ; 找到中间值 </span>
                 <span class="token comment" spellcheck="true">//为了避免int不越值 我们重新换一种写法 </span>
                 <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span> r <span class="token operator">-</span> l <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">;</span>

                 <span class="token keyword">if</span><span class="token punctuation">(</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token punctuation">)</span>
                     <span class="token keyword">return</span> mid <span class="token punctuation">;</span>

                 <span class="token keyword">if</span><span class="token punctuation">(</span> target <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token punctuation">)</span>
                     <span class="token comment" spellcheck="true">//在 arr[l.....mid-1] 中找target </span>
                     r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">;</span>

                 <span class="token keyword">else</span> 
                     <span class="token comment" spellcheck="true">//在 arr[mid+1 ... r ] 中找target</span>
                     l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">;</span>    

             <span class="token punctuation">}</span>
             <span class="token comment" spellcheck="true">//没找到返回-1 </span>
             <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="二分搜索树-Binary-Search-Tree"><a href="#二分搜索树-Binary-Search-Tree" class="headerlink" title="二分搜索树  Binary Search Tree"></a>二分搜索树  Binary Search Tree</h3><ul>
<li>树是一个很强大的数据结构  他能高效的解决查找问题 </li>
</ul>
<p><img src="http://onh0umlhz.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91.PNG" alt="ecs"></p>
<ul>
<li><p>二叉树 &amp;&amp; 每个节点的键值都大于左子树 &amp;&amp; 每个节点的键值都小于右孩子 &amp;&amp; 以左右子树为根的子树依然时二分搜索树 </p>
</li>
<li><p>BST不一定是一个完全 二叉树 所以我们不能用数组实现BST 我们就只能用指针构建的Node节点来实现 </p>
</li>
</ul>
<p><img src="http://onh0umlhz.bkt.clouddn.com/BST%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.PNG" alt="BST"></p>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Key<span class="token punctuation">,</span><span class="token keyword">typename</span> Value<span class="token operator">></span>
        <span class="token keyword">class</span> <span class="token class-name">BinarySearchTree</span>
        <span class="token punctuation">{</span>
        <span class="token keyword">private</span><span class="token operator">:</span>
            <span class="token comment" spellcheck="true">//----------------------------------------</span>
            <span class="token keyword">struct</span> Node   <span class="token comment" spellcheck="true">//节点</span>
            <span class="token punctuation">{</span>
                Key key<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 键</span>
                Value value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 值</span>
                Node <span class="token operator">*</span>left <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//用来指向左节点</span>
                Node <span class="token operator">*</span>right <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//用来指向右节点</span>

                <span class="token comment" spellcheck="true">//以键值的方式构建一个新的节点 </span>
                <span class="token function">Node</span><span class="token punctuation">(</span>Key key <span class="token punctuation">,</span>Value value<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">=</span> key <span class="token punctuation">;</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>value <span class="token operator">=</span> value <span class="token punctuation">;</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">//以一个node来构建一个新的node （copy）</span>
                <span class="token function">Node</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>key <span class="token punctuation">;</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>value <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>value <span class="token punctuation">;</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

            <span class="token punctuation">}</span><span class="token punctuation">;</span>

            Node <span class="token operator">*</span>root <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//根节点</span>
            <span class="token keyword">int</span> count <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//计数</span>

        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>这样我们就构建了一个基本的BinarySearchTree类  </p>
</li>
<li><p>构造方法和析构方法我们简单的说一下 对于构造来说很简单 首先root 置为NULL count++ </p>
</li>
<li><p>对于析构来说 比较复杂 它涉及到DFS(深度优先搜索) 所以我们在文章的后半段来实现这个析构 </p>
</li>
<li><p>那我们先来实现几个简单的方法 </p>
</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token comment" spellcheck="true">//构造 </span>
        <span class="token function">BinarySearchTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            root <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>
            count <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//析构</span>
        <span class="token operator">~</span><span class="token function">BinarySearchTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">destory</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//树的大小</span>
        <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> count <span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//树是否为空 </span>
        <span class="token keyword">int</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="二分搜索树-的方法"><a href="#二分搜索树-的方法" class="headerlink" title="二分搜索树 的方法"></a>二分搜索树 的方法</h3><h4 id="插入新的节点-Insert"><a href="#插入新的节点-Insert" class="headerlink" title="插入新的节点 Insert"></a>插入新的节点 Insert</h4><ul>
<li>首先 要插入一个新的节点 我们就要拿这个节点与我们的树作比较 如果比root大 就要根root的右子树的根比较<br><img src="http://onh0umlhz.bkt.clouddn.com/%E6%8F%92%E5%85%A501.PNG" alt="01"></li>
<li>相反 如果比root大 就要根root的左子树的根比较 ，直到发现root的某个子树的root为NULL 那么这个地方就是他应该所在的位置了 。<br><img src="http://onh0umlhz.bkt.clouddn.com/%E6%8F%92%E5%85%A502.PNG" alt="02"></li>
<li>如果恰好找到了这个值相等的root，那我们就要用新的值 去覆盖原来的值 。<br><img src="http://onh0umlhz.bkt.clouddn.com/%E6%8F%92%E5%85%A503.PNG" alt="03"></li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span> 
        <span class="token comment" spellcheck="true">//内部实现的递归的插入方法</span>
        <span class="token comment" spellcheck="true">//在 node为根的树中 插入(k,v)</span>

        Node <span class="token operator">*</span> <span class="token function">insert</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node <span class="token punctuation">,</span>Key key <span class="token punctuation">,</span>Value value<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//向以node为根的BST中 插入节点(k,v)  返回值为新的BST的根节点</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//如果子树为空 或者根为空 遇到为空的 ，就返回一个新节点</span>
                count<span class="token operator">++</span> <span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//与根相同的话  更新这个node  </span>
                node<span class="token operator">-</span><span class="token operator">></span>value <span class="token operator">=</span> value <span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//如果比node的值小，则去向左子树插入 我们递归的去把左子树的root传入，寻找合适的位置   </span>
                node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//如果比node的值大，则插入到右子树</span>
                node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right <span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        <span class="token comment" spellcheck="true">//外界调用的插入方法</span>
        <span class="token keyword">void</span> <span class="token function">insert</span> <span class="token punctuation">(</span>Key key <span class="token punctuation">,</span>Value value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            root <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>这样，我们就做完了向一个二分搜索树中插入元素的操作 ，接下来，我们要做的就是在这个树里面去寻找节点了。</li>
</ul>
<h4 id="寻找节点是否存在-contain"><a href="#寻找节点是否存在-contain" class="headerlink" title="寻找节点是否存在 contain"></a>寻找节点是否存在 contain</h4><ul>
<li>思路其实跟插入的思路是一样的，我们判断我们要找的key是不是与根节点相同 否则的话 再根据key的大于与node.key的大小递归的去他的左右子树去寻找。</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span> 

        <span class="token comment" spellcheck="true">//在 node为根的树中 是否包含key</span>
        <span class="token keyword">bool</span> <span class="token function">contain</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node <span class="token punctuation">,</span>Key key<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//如果直到叶子节点还没找到 返回false </span>
                <span class="token keyword">return</span>  <span class="token boolean">false</span> <span class="token punctuation">;</span> 
            <span class="token punctuation">}</span>

            <span class="token comment" spellcheck="true">/*
                同样的思路 我们判断我们要找的key是不是与根节
                点相同 否则的话 再根据key的大于与node.key
                的大小递归的去他的左右子树去寻找 
            */</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> node<span class="token operator">-</span><span class="token operator">></span>key <span class="token punctuation">)</span> <span class="token keyword">return</span>  <span class="token boolean">true</span> <span class="token punctuation">;</span>  

            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> key <span class="token operator">&lt;</span> node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">contain</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">else</span> <span class="token keyword">return</span>  <span class="token function">contain</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        <span class="token keyword">bool</span> <span class="token function">contain</span><span class="token punctuation">(</span>Key key <span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">contain</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="提取值的查找-Search"><a href="#提取值的查找-Search" class="headerlink" title="提取值的查找 Search"></a>提取值的查找 Search</h4><ul>
<li><p>search函数的设计方法有很多种 也是根据自己的实际情况去设计 ，难点不是查找的算法 而是这个函数的返回值 </p>
</li>
<li><p>有些情况 ，直接返回返回一个node节点 这就要去外界人员去了解node的内部构造 这显然是很麻烦的 </p>
</li>
<li><p>还有情况 返回的是node.value 这个情况也有很多问题 首先你必须保证value的值不为空 否侧c++语言是不能为一个int返回NULL的 </p>
</li>
<li><p>这样，我们在研究算法 ，我们当然要考虑值的安全性 所以这里 我们以Value* 作为返回值 这样 当他的值不存在是 指针是可以返回一个NULL表示的 。</p>
</li>
<li><p>了解了这个 算法其实就很好解决了 ，我们按照前面所讲的思路 递归的对他进行查找 </p>
</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">public</span> <span class="token operator">:</span>
        <span class="token comment" spellcheck="true">//在node为根的树中 搜索包含key的值</span>

        Value<span class="token operator">*</span> <span class="token function">search</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node <span class="token punctuation">,</span>Key key<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//找不到的情况 就返回NULL</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword">return</span>  <span class="token constant">NULL</span> <span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">/*
                同样，我们分三种情况对他进行二分搜索 
                这里 我们的返回值是 当前找到的这个根节点 他的value值所在的地址 
                清楚了这个 我们就可以按照先前的思路 对他进行递归查找了 
            */</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> node<span class="token operator">-</span><span class="token operator">></span>key <span class="token punctuation">)</span> <span class="token keyword">return</span>  <span class="token operator">&amp;</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>value<span class="token punctuation">)</span> <span class="token punctuation">;</span>

            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> key <span class="token operator">&lt;</span> node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">else</span> <span class="token keyword">return</span>  <span class="token function">search</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>

        <span class="token keyword">private</span> <span class="token operator">:</span>  

        Value<span class="token operator">*</span> <span class="token function">search</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>root <span class="token punctuation">,</span>key <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS(深度优先搜索)"></a>DFS(深度优先搜索)</h4><ul>
<li><p>DFS 深度优先搜索 顾名思义 他是一个树一个树  从根节点 一至到叶子节点的遍历 </p>
</li>
<li><p>我么们来讲三种遍历方法的共同点和不同点 大家可以先草率的看一下代码 就会发现 出奇的相似 只是改了一下名称和顺序 </p>
</li>
<li><p>对 这就是三个顺序的遍历 其实他们走过的路径是一模一样的  </p>
</li>
<li><p>他的思想就是 只有节点不为空 他就一直向着他的孩子节点递归 直到为空返回 返回回来 他又会向着另一边深入去递归 直到找到叶子节点为空 </p>
</li>
<li><p>每一个节点都会被路过三次 转个圈也算三次 (看似三次) 那么这三种遍历方法区别就在于 第几次遍历他的时候 打印他的值 。</p>
</li>
</ul>
<h5 id="前序遍历-preOrder"><a href="#前序遍历-preOrder" class="headerlink" title="前序遍历 preOrder"></a>前序遍历 preOrder</h5><pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span> 

        <span class="token comment" spellcheck="true">//在node为根的树中 对他进行前序遍历</span>
        <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                cout<span class="token operator">&lt;&lt;</span>node<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
                <span class="token function">preOrder</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">preOrder</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="中序遍历-inOrder"><a href="#中序遍历-inOrder" class="headerlink" title="中序遍历 inOrder"></a>中序遍历 inOrder</h5><pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span> 

        <span class="token comment" spellcheck="true">//在node为根的树中 对他进行中序遍历</span>
        <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                cout<span class="token operator">&lt;&lt;</span>node<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
                <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="后序遍历-postOrder"><a href="#后序遍历-postOrder" class="headerlink" title="后序遍历 postOrder"></a>后序遍历 postOrder</h5><pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span> 

        <span class="token comment" spellcheck="true">//在node为根的树中 对他进行后序遍历</span>
        <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">postOrder</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">postOrder</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
                cout<span class="token operator">&lt;&lt;</span>node<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>如何去理解三种遍历方法 我也给出了 一种简单的方法去记 。</p>
</li>
<li><p>每一个节点都被箭头指向三次 第几次被指 就是什么遍历 </p>
</li>
<li><p>红箭头指向<br><img src="http://onh0umlhz.bkt.clouddn.com/miccall%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" alt="前"></p>
</li>
<li>绿箭头指向<br><img src="http://onh0umlhz.bkt.clouddn.com/miccall%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" alt="中"></li>
<li>蓝箭头指向<br><img src="http://onh0umlhz.bkt.clouddn.com/miccall%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" alt="后"></li>
</ul>
<h4 id="BSF-广度优先搜索-levelOrder-层次遍历"><a href="#BSF-广度优先搜索-levelOrder-层次遍历" class="headerlink" title="BSF (广度优先搜索) levelOrder 层次遍历"></a>BSF (广度优先搜索) levelOrder 层次遍历</h4><ul>
<li><p>层次遍历对比与DFS的重要性和复杂性来说要低很多 但也是非常重要的思想 </p>
</li>
<li><p>他是层次遍历 也就是所 他是一级一级遍历的 所以我们得想办法记录不同的根节点 </p>
</li>
<li><p>很容易我们想到 可以用队列的方式来暂时存取我们记录的层的节点 </p>
</li>
<li><p>当一层遍历结束 我们从队列的最前面取出一个节点 对他的子节点进行入队 这样 第一层结束后 紧接着的就是第二层的遍历 </p>
</li>
<li><p>以此类推 。</p>
</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span>

        <span class="token comment" spellcheck="true">//在node为根的树中 对他进行层序遍历</span>
        <span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>root<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            queue<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span> q <span class="token punctuation">;</span> 
            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//当队列不为空我们对他进行遍历 </span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                Node <span class="token operator">*</span>node <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//取出一个节点 </span>
                q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//让这个点处队 </span>

                cout<span class="token operator">&lt;&lt;</span>node<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 打印这个点 </span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果她有左子树 那么把他入队 </span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//同时 如果她有右子树 也把他入队 </span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>


        <span class="token keyword">public</span> <span class="token operator">:</span> 

        <span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">levelOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="寻找最大值与最小值"><a href="#寻找最大值与最小值" class="headerlink" title="寻找最大值与最小值"></a>寻找最大值与最小值</h4><ul>
<li>如果你前面都非常理解了 就会很容易的知道 最大值 就在最右的子节点 相同的 最小值 就在最左的字节点 </li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">
        <span class="token keyword">private</span> <span class="token operator">:</span> 

        <span class="token comment" spellcheck="true">//寻找最小值 以node为根的树找最小值 返回最小值节点 </span>
        Node <span class="token operator">*</span> <span class="token function">minimum</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> node <span class="token punctuation">;</span>

            <span class="token keyword">return</span> <span class="token function">minimum</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 一直向左子树寻找 </span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">//寻找最大值 以node为根的树找最大值 返回最大值节点</span>
         Node <span class="token operator">*</span> <span class="token function">maximum</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> node <span class="token punctuation">;</span>

            <span class="token keyword">return</span> <span class="token function">maximum</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//向右子树寻找 </span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        Key <span class="token function">minimum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">assert</span><span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            Node<span class="token operator">*</span> minNode <span class="token operator">=</span> <span class="token function">minimum</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token keyword">return</span> minNode<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>

        Key <span class="token function">maximum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">assert</span><span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            Node <span class="token operator">*</span>maxNode <span class="token operator">=</span> <span class="token function">minimum</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> maxNode<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="移除最大值与最小值"><a href="#移除最大值与最小值" class="headerlink" title="移除最大值与最小值"></a>移除最大值与最小值</h4><ul>
<li><p>移除最小值有两种情况 一种是他没有右子树 那么问题就简单了 我们可以直接移除这个值 </p>
</li>
<li><p>但是另一种情况 他有右子树 我们怎样处理呢 其实也简单 。他的右子树虽然都比他本身大 但是肯定比他的父亲节点小 ，所以我们只要简单的 把右子树的节点移过来 代替删除的最小节点 ，让他成为最小值父亲的左子树 ，就可以了。</p>
</li>
<li><p>类似的情况 我们删除他的最大值也是这样 如果他有左孩子的话 因为他的左孩子依然是一个二分搜索树 。也可以直接把他移过来就可以了 。</p>
</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> ：

        <span class="token comment" spellcheck="true">//移除最小值 删除以node为根的BST中的最小值 返回删除之后新的根 </span>
        Node <span class="token operator">*</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node <span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果左子树为空 那么我们找到了这个最小值 </span>
            <span class="token punctuation">{</span>
                Node <span class="token operator">*</span> rightNode <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right <span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//看看右子树是否存在 为NULL也可以 </span>
                <span class="token keyword">delete</span> node <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//删除 node </span>
                count<span class="token operator">--</span> <span class="token punctuation">;</span>      
                <span class="token keyword">return</span> rightNode <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  </span>
            <span class="token punctuation">}</span>
            node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//继续寻找 </span>
            <span class="token keyword">return</span>  node <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回这个根 </span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">//移除最大值 同理 </span>
        Node <span class="token operator">*</span> <span class="token function">removeMax</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node <span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                Node <span class="token operator">*</span> leftNode <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left <span class="token punctuation">;</span>
                <span class="token keyword">delete</span> node <span class="token punctuation">;</span>
                count<span class="token operator">--</span> <span class="token punctuation">;</span>
                <span class="token keyword">return</span> leftNode <span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span>  node <span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> ： 
        <span class="token keyword">void</span> <span class="token function">removeMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果根不会空 </span>
                root <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span> root <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">void</span> <span class="token function">removeMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
                root <span class="token operator">=</span> <span class="token function">removeMax</span><span class="token punctuation">(</span> root <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="移除任意一个值"><a href="#移除任意一个值" class="headerlink" title="移除任意一个值"></a>移除任意一个值</h4><ul>
<li><p>1.为什么要讲删除最大值和最小值呢 因为最坏的情况下 最小值只有右孩子 最大值只有左孩子 这为我们删除任意值奠定了基础。因为这种方法可以删除任意一个只有一个孩子的节点。</p>
</li>
<li><p>2.最难的情况可想而知了 删除一个任意一个节点 他可以有左右两个子树 。</p>
</li>
<li><p>3.假设我们删除一个节点 我们设他为 d  据我们的经验 删除这个节点 ，必定要找一个值来代替他 ，那么是从他的左右孩子中找吗 ，那不一定 我们想 应该是找一个最接近他的值才可以 但是我们也知道 以d为根的子树 右边得找一个最小值 左边得找一个最大值 才能最接近d 。</p>
</li>
<li><p>4.那我们就假设是 s 是d 的取代值 那么 s = min(d.right)  </p>
</li>
<li><p>5.找到s之后呢 我们先拿出来s节点 ，然后就要用我们之前的方法 删除d.right的最小值 也就是s节点，  然后把拿出来的s节点的右子树指向这个d.right。 然后 s.left = d.left 这个左子树不能丢 也得找到 。</p>
</li>
<li><p>6.这样就就绪了 那么现在就可以放心的删除d这个节点了。 这样 s 就是新的子树的根 </p>
</li>
<li><p>其实，我们也可以找 s = max(d.left) 同样也是可以的 这里我们就不写了 </p>
</li>
<li><p>O(logn)</p>
</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span>

        <span class="token comment" spellcheck="true">//删除以node为根 树中键值为key的节点</span>
        <span class="token comment" spellcheck="true">//返回一个删除节点后的新的 根</span>

        Node<span class="token operator">*</span> <span class="token function">remove</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> Key key<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//找不到这个节点 </span>
                <span class="token keyword">return</span>  <span class="token constant">NULL</span><span class="token punctuation">;</span> 
            <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//二分搜索</span>
                node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> 
                <span class="token keyword">return</span> node<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">></span>node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//二分搜索</span>
                node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> node<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span><span class="token punctuation">{</span>

                <span class="token comment" spellcheck="true">// 找到了这个节点node </span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//只有右孩子</span>
                <span class="token punctuation">{</span>
                    Node <span class="token operator">*</span> rightnode <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right <span class="token punctuation">;</span>
                    <span class="token keyword">delete</span> node <span class="token punctuation">;</span>
                    count <span class="token operator">--</span> <span class="token punctuation">;</span>
                    <span class="token keyword">return</span> rightnode <span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//只有左 孩子</span>
                <span class="token punctuation">{</span>
                    Node <span class="token operator">*</span> leftnode <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left <span class="token punctuation">;</span>
                    <span class="token keyword">delete</span> node <span class="token punctuation">;</span>
                    count <span class="token operator">--</span> <span class="token punctuation">;</span>
                    <span class="token keyword">return</span> leftnode <span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">// 有两个孩子 </span>

                <span class="token comment" spellcheck="true">//Node * delnode = node ;  先保存这个节点(其实没必要)</span>

                Node <span class="token operator">*</span> successor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token function">minimum</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
                <span class="token comment" spellcheck="true">// node的最小值所在的节点 就是我们要拿来替换的节点 这里我们为了避免指针指向失败的问题 重新开一个空间节点 </span>

                count<span class="token operator">++</span> <span class="token punctuation">;</span>

                successor<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  
                <span class="token comment" spellcheck="true">//removeMin的时候 会把successor delete掉 导致successor失效 所以我们必须开一个新的节点来存储这个值 </span>

                successor<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left <span class="token punctuation">;</span>  

                <span class="token comment" spellcheck="true">//删除这个节点  </span>
                <span class="token keyword">delete</span> node<span class="token punctuation">;</span>
                count <span class="token operator">--</span> <span class="token punctuation">;</span>
                <span class="token keyword">return</span> successor <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//新的节点 </span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        <span class="token comment" spellcheck="true">//删除键值为key的节点 </span>
        <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            root <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul>
<li>有了前面一大片的铺垫 相信这个析构函数就很好解决了 我们通过对他进行后序遍历 并把他一个一个销毁</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">
        <span class="token keyword">private</span> <span class="token operator">:</span>
        <span class="token comment" spellcheck="true">//在node为根的树中 对他进行后序遍历 并把他销毁</span>
        <span class="token keyword">void</span> <span class="token function">destory</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">destory</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">destory</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">delete</span> node<span class="token punctuation">;</span>
                count<span class="token operator">--</span> <span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token operator">:</span>
        <span class="token operator">~</span><span class="token function">BinarySearchTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">destory</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="其他的一些知识"><a href="#其他的一些知识" class="headerlink" title="其他的一些知识"></a>其他的一些知识</h3><ul>
<li>排序</li>
<li>最大最小值 </li>
<li>前驱后继 </li>
<li>floor和ceil<br>floor表示 ： 如果树中没有key 那么 就找最接近这个值，且小于这个值的key所对应的value<br>ceil正好相反 如果树中没有key 那么 就找最接近这个值，且大于这个值的key所对应的value</li>
<li>rank和select<br>rank ： 某一个key在一个树中排名第几<br>select ： 在一个树中 排名第n的元数是谁</li>
<li>支持重复元素的二分搜索 </li>
</ul>
<h3 id="BST的局限性"><a href="#BST的局限性" class="headerlink" title="BST的局限性"></a>BST的局限性</h3><ul>
<li><p>同样的数据 ，可能对应不同的BST 一个顺序的存入方式 可以使得一个树退化成一个链表 。可能导致比顺序查找都慢 (递归的时间消耗和两个指针的搜索)</p>
</li>
<li><p>解决方法 ： 平衡二叉树 __红黑树,2-3树,AVL树,Splay树等 使二叉树不能退化成链表</p>
</li>
<li><p>平衡二叉树和堆的结合__ Treap   </p>
</li>
</ul>
<h3 id="其他递归问题"><a href="#其他递归问题" class="headerlink" title="其他递归问题"></a>其他递归问题</h3><ul>
<li>归并排序 </li>
<li>快速排序 </li>
<li>搜索问题</li>
<li>决策树 </li>
<li>8数码 </li>
<li>8皇后 </li>
<li>KD树 区间树 哈夫曼树 </li>
</ul>

    

    
</div>


                

                <!-- Post Comments -->
                
                    






    <!-- 使用 DISQUS_CLICK -->
    <div id="disqus-comment">
        <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #757575;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load"> 
    <button class="disqus_click_btn">阅读评论（请确保 disqus 可以正常加载）</button>
</div>

<script type="text/ls-javascript" id="disqus-lazy-load-script">
    var disqus_config = function () {
        this.page.url = 'http://miccall.tech/2017/04/27/algorithm/BST/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://miccall.tech/2017/04/27/algorithm/BST/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
  	

    </div>
    <style>
        #disqus-comment{
            background-color: #eee;
            padding: 2pc;
        }
    </style>




                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2017/05/04/algorithm/Union/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2017/04/17/algorithm/sort/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/preview.gif);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/BA201701210404530018-00-000000.png" alt="miccall's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        316459829@qq.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="mailto:316459829@qq.com" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
                <li>
                    <a href="http://wpa.qq.com/msgrd?v=3&amp;uin=316459829&amp;site=qq&amp;menu=yes" target="_blank" title="腾讯 QQ">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">phone</i>
                        
                        腾讯 QQ
                    </a>
                </li>
            
                <li>
                    <a href="http://blog.csdn.net/qq_31411825" target="_blank" title="CSDN">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">user</i>
                        
                        CSDN
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/" rel="nofollow">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2017/05/">五月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/04/">四月 2017<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/03/">三月 2017<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/02/">二月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/01/">一月 2017<span class="sidebar_archives-count">18</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">chrome_reader_mode</i>
                
                分类
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
                <li>
                <a class="sidebar_archives-link" href="/categories/Algorithm/">Algorithm<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/categories/Android/">Android<span class="sidebar_archives-count">13</span></a></li><li><a class="sidebar_archives-link" href="/categories/Leap-Motion/">Leap Motion<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/categories/unity-3d/">unity 3d<span class="sidebar_archives-count">4</span></a>
            </ul>
        </li>
        
    

    <!-- Pages  -->
    
        <li>
            <a href="/about/" title="简历">
                
                    <i class="material-icons sidebar-material-icons">person</i>
                
                简历
            </a>
        </li>
        
    
        <li>
            <a href="/group/" title="团队">
                
                    <i class="material-icons sidebar-material-icons">group</i>
                
                团队
            </a>
        </li>
        
    
        <li>
            <a href="/gallery/" title="图库">
                
                    <i class="material-icons sidebar-material-icons">image</i>
                
                图库
            </a>
        </li>
        
    
        <li>
            <a href="/tag/" title="标签">
                
                    <i class="material-icons sidebar-material-icons">dashboard</i>
                
                标签
            </a>
        </li>
        
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    

    <!-- Google + -->
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>Mr.Metro
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import File -->


    <script>lsloader.load("js/lazyload.min.js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==")</script>
    <script>lsloader.load("js/js.min.js","/js/js.min.js?y3mFBzHggMykAk6nhSWv/A==")</script>



    <script>lsloader.load("js/nprogress.js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==")</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#FF4081'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #FF4081, 0 0 15px #FF4081'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#FF4081',
        'border-left-color': '#FF4081'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>



    
        <script>lsloader.load("js/smoothscroll.js","/js/smoothscroll.js?lOy/ACj5suSNi7ZVFVbpFQ==")</script>
    





    <!-- Busuanzi -->
    <script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>










<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Window Load-->
<script type="text/ls-javascript" id="window-load">
    $(window).load(function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });
</script>

<!-- MathJax Load-->

<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Bing Background -->


<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: canary | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
