<!DOCTYPE HTML>
<html>

<head>
	
			
    <title>
    Mr.Metro
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>

			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-coy.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/ok_prism.css" />

<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a></li><li><a class="category-link" href="/categories/Android/">Android</a></li><li><a class="category-link" href="/categories/Design/">Design</a></li><li><a class="category-link" href="/categories/Leap-Motion/">Leap Motion</a></li><li><a class="category-link" href="/categories/unity-3d/">unity 3d</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/miccall" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1492448025770&amp;di=4947a369fb680fbc9563ce8d5f60d451&amp;imgtype=0&amp;src=http%3A%2F%2Fcdn.duitang.com%2Fuploads%2Fitem%2F201408%2F01%2F20140801065530_iPjAZ.png);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >我的算法之路 -- BST二叉搜索树</h2></a>
            </div>
            <!-- Post -->
            <div class="post-content" style="padding: 4rem 4rem 2rem 4rem ;" >
                <hr>
<h1 id="我的算法之路-–-BST二叉搜索树"><a href="#我的算法之路-–-BST二叉搜索树" class="headerlink" title=" 我的算法之路 – BST二叉搜索树  "></a><strong> 我的算法之路 – BST二叉搜索树  </strong></h1><h6 id="Created-by-miccall-转载请注明出处"><a href="#Created-by-miccall-转载请注明出处" class="headerlink" title="Created by miccall   (转载请注明出处)"></a>Created by miccall   (<a href="http://miccall.tech">转载请注明出处</a>)</h6><ul>
<li><p>按理说这类文章首先应该讲一些鸡汤啊 鼓励学习什么的话    但是没有</p>
</li>
<li><p>按理说这类文章应该有一些推荐路径或者学习方法           但是没有 </p>
</li>
<li><p>按理说这个文章应该和其他的类似 讲些算法之坑            但是没有 </p>
</li>
<li><p>那这篇文章出现的意义是什么 没什么 就是我的学习之路  你爱看就看看 </p>
</li>
</ul>
<h3 id="二分查找-Binary-Search"><a href="#二分查找-Binary-Search" class="headerlink" title="二分查找 Binary Search"></a>二分查找 Binary Search</h3><ul>
<li><p>对于有序列 才能使用二分查找法 </p>
</li>
<li><p>对于有序列 先比较数组中间的元素 ‘v’ 与 我们想要查找元素的大小 </p>
</li>
<li><p>如果正好相等，那么很幸运 我们找到了这个元素 </p>
</li>
<li><p>此时 ，数组就被 ‘v’ 分成了两半 一半全部小于’v’ ，另一半则大于 ‘v’。</p>
</li>
<li><p>那么我就知道了 ，我们可以递归的在这两个分开的数组中找我们想要找的元素了。</p>
</li>
</ul>
<p><img src="http://onh0umlhz.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE01.PNG" alt="erfen"></p>
<ul>
<li>这里我给出非递归的实现方式 有兴趣的可以尝试递归的方式 或者网上一搜一大片。</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token comment" spellcheck="true">//首先我们给定有序列arr 长度n 搜索元素 target 返回他的位置 </span>
        <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
        <span class="token keyword">int</span> <span class="token function">BinarySearch</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token keyword">int</span> n <span class="token punctuation">,</span> T target<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
             <span class="token comment" spellcheck="true">//在 arr[l....r] 之中查找 target </span>
             <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token number">-1</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//区间 有边界是n-1 他是一个闭区间</span>

             <span class="token comment" spellcheck="true">//当区间还有元素时 </span>
             <span class="token keyword">while</span><span class="token punctuation">(</span> l <span class="token operator">&lt;=</span> r <span class="token punctuation">)</span> 
             <span class="token punctuation">{</span>
                 <span class="token comment" spellcheck="true">//int mid = ( l + r ) / 2 ; 找到中间值 </span>
                 <span class="token comment" spellcheck="true">//为了避免int不越值 我们重新换一种写法 </span>
                 <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span> r <span class="token operator">-</span> l <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">;</span>

                 <span class="token keyword">if</span><span class="token punctuation">(</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token punctuation">)</span>
                     <span class="token keyword">return</span> mid <span class="token punctuation">;</span>

                 <span class="token keyword">if</span><span class="token punctuation">(</span> target <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token punctuation">)</span>
                     <span class="token comment" spellcheck="true">//在 arr[l.....mid-1] 中找target </span>
                     r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">;</span>

                 <span class="token keyword">else</span> 
                     <span class="token comment" spellcheck="true">//在 arr[mid+1 ... r ] 中找target</span>
                     l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">;</span>    

             <span class="token punctuation">}</span>
             <span class="token comment" spellcheck="true">//没找到返回-1 </span>
             <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="二分搜索树-Binary-Search-Tree"><a href="#二分搜索树-Binary-Search-Tree" class="headerlink" title="二分搜索树  Binary Search Tree"></a>二分搜索树  Binary Search Tree</h3><ul>
<li>树是一个很强大的数据结构  他能高效的解决查找问题 </li>
</ul>
<p><img src="http://onh0umlhz.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91.PNG" alt="ecs"></p>
<ul>
<li><p>二叉树 &amp;&amp; 每个节点的键值都大于左子树 &amp;&amp; 每个节点的键值都小于右孩子 &amp;&amp; 以左右子树为根的子树依然时二分搜索树 </p>
</li>
<li><p>BST不一定是一个完全 二叉树 所以我们不能用数组实现BST 我们就只能用指针构建的Node节点来实现 </p>
</li>
</ul>
<p><img src="http://onh0umlhz.bkt.clouddn.com/BST%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.PNG" alt="BST"></p>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> Key<span class="token punctuation">,</span><span class="token keyword">typename</span> Value<span class="token operator">></span>
        <span class="token keyword">class</span> <span class="token class-name">BinarySearchTree</span>
        <span class="token punctuation">{</span>
        <span class="token keyword">private</span><span class="token operator">:</span>
            <span class="token comment" spellcheck="true">//----------------------------------------</span>
            <span class="token keyword">struct</span> Node   <span class="token comment" spellcheck="true">//节点</span>
            <span class="token punctuation">{</span>
                Key key<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 键</span>
                Value value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 值</span>
                Node <span class="token operator">*</span>left <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//用来指向左节点</span>
                Node <span class="token operator">*</span>right <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//用来指向右节点</span>

                <span class="token comment" spellcheck="true">//以键值的方式构建一个新的节点 </span>
                <span class="token function">Node</span><span class="token punctuation">(</span>Key key <span class="token punctuation">,</span>Value value<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">=</span> key <span class="token punctuation">;</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>value <span class="token operator">=</span> value <span class="token punctuation">;</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">//以一个node来构建一个新的node （copy）</span>
                <span class="token function">Node</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>key <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>key <span class="token punctuation">;</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>value <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>value <span class="token punctuation">;</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>
                    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

            <span class="token punctuation">}</span><span class="token punctuation">;</span>

            Node <span class="token operator">*</span>root <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//根节点</span>
            <span class="token keyword">int</span> count <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//计数</span>

        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>这样我们就构建了一个基本的BinarySearchTree类  </p>
</li>
<li><p>构造方法和析构方法我们简单的说一下 对于构造来说很简单 首先root 置为NULL count++ </p>
</li>
<li><p>对于析构来说 比较复杂 它涉及到DFS(深度优先搜索) 所以我们在文章的后半段来实现这个析构 </p>
</li>
<li><p>那我们先来实现几个简单的方法 </p>
</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token comment" spellcheck="true">//构造 </span>
        <span class="token function">BinarySearchTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            root <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>
            count <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//析构</span>
        <span class="token operator">~</span><span class="token function">BinarySearchTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">destory</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//树的大小</span>
        <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> count <span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//树是否为空 </span>
        <span class="token keyword">int</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="二分搜索树-的方法"><a href="#二分搜索树-的方法" class="headerlink" title="二分搜索树 的方法"></a>二分搜索树 的方法</h3><h4 id="插入新的节点-Insert"><a href="#插入新的节点-Insert" class="headerlink" title="插入新的节点 Insert"></a>插入新的节点 Insert</h4><ul>
<li>首先 要插入一个新的节点 我们就要拿这个节点与我们的树作比较 如果比root大 就要根root的右子树的根比较<br><img src="http://onh0umlhz.bkt.clouddn.com/%E6%8F%92%E5%85%A501.PNG" alt="01"></li>
<li>相反 如果比root大 就要根root的左子树的根比较 ，直到发现root的某个子树的root为NULL 那么这个地方就是他应该所在的位置了 。<br><img src="http://onh0umlhz.bkt.clouddn.com/%E6%8F%92%E5%85%A502.PNG" alt="02"></li>
<li>如果恰好找到了这个值相等的root，那我们就要用新的值 去覆盖原来的值 。<br><img src="http://onh0umlhz.bkt.clouddn.com/%E6%8F%92%E5%85%A503.PNG" alt="03"></li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span> 
        <span class="token comment" spellcheck="true">//内部实现的递归的插入方法</span>
        <span class="token comment" spellcheck="true">//在 node为根的树中 插入(k,v)</span>

        Node <span class="token operator">*</span> <span class="token function">insert</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node <span class="token punctuation">,</span>Key key <span class="token punctuation">,</span>Value value<span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//向以node为根的BST中 插入节点(k,v)  返回值为新的BST的根节点</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//如果子树为空 或者根为空 遇到为空的 ，就返回一个新节点</span>
                count<span class="token operator">++</span> <span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//与根相同的话  更新这个node  </span>
                node<span class="token operator">-</span><span class="token operator">></span>value <span class="token operator">=</span> value <span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//如果比node的值小，则去向左子树插入 我们递归的去把左子树的root传入，寻找合适的位置   </span>
                node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//如果比node的值大，则插入到右子树</span>
                node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right <span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        <span class="token comment" spellcheck="true">//外界调用的插入方法</span>
        <span class="token keyword">void</span> <span class="token function">insert</span> <span class="token punctuation">(</span>Key key <span class="token punctuation">,</span>Value value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            root <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>这样，我们就做完了向一个二分搜索树中插入元素的操作 ，接下来，我们要做的就是在这个树里面去寻找节点了。</li>
</ul>
<h4 id="寻找节点是否存在-contain"><a href="#寻找节点是否存在-contain" class="headerlink" title="寻找节点是否存在 contain"></a>寻找节点是否存在 contain</h4><ul>
<li>思路其实跟插入的思路是一样的，我们判断我们要找的key是不是与根节点相同 否则的话 再根据key的大于与node.key的大小递归的去他的左右子树去寻找。</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span> 

        <span class="token comment" spellcheck="true">//在 node为根的树中 是否包含key</span>
        <span class="token keyword">bool</span> <span class="token function">contain</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node <span class="token punctuation">,</span>Key key<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//如果直到叶子节点还没找到 返回false </span>
                <span class="token keyword">return</span>  <span class="token boolean">false</span> <span class="token punctuation">;</span> 
            <span class="token punctuation">}</span>

            <span class="token comment" spellcheck="true">/*
                同样的思路 我们判断我们要找的key是不是与根节
                点相同 否则的话 再根据key的大于与node.key
                的大小递归的去他的左右子树去寻找 
            */</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> node<span class="token operator">-</span><span class="token operator">></span>key <span class="token punctuation">)</span> <span class="token keyword">return</span>  <span class="token boolean">true</span> <span class="token punctuation">;</span>  

            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> key <span class="token operator">&lt;</span> node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">contain</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">else</span> <span class="token keyword">return</span>  <span class="token function">contain</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        <span class="token keyword">bool</span> <span class="token function">contain</span><span class="token punctuation">(</span>Key key <span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">contain</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="提取值的查找-Search"><a href="#提取值的查找-Search" class="headerlink" title="提取值的查找 Search"></a>提取值的查找 Search</h4><ul>
<li><p>search函数的设计方法有很多种 也是根据自己的实际情况去设计 ，难点不是查找的算法 而是这个函数的返回值 </p>
</li>
<li><p>有些情况 ，直接返回返回一个node节点 这就要去外界人员去了解node的内部构造 这显然是很麻烦的 </p>
</li>
<li><p>还有情况 返回的是node.value 这个情况也有很多问题 首先你必须保证value的值不为空 否侧c++语言是不能为一个int返回NULL的 </p>
</li>
<li><p>这样，我们在研究算法 ，我们当然要考虑值的安全性 所以这里 我们以Value* 作为返回值 这样 当他的值不存在是 指针是可以返回一个NULL表示的 。</p>
</li>
<li><p>了解了这个 算法其实就很好解决了 ，我们按照前面所讲的思路 递归的对他进行查找 </p>
</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">public</span> <span class="token operator">:</span>
        <span class="token comment" spellcheck="true">//在node为根的树中 搜索包含key的值</span>

        Value<span class="token operator">*</span> <span class="token function">search</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node <span class="token punctuation">,</span>Key key<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//找不到的情况 就返回NULL</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword">return</span>  <span class="token constant">NULL</span> <span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">/*
                同样，我们分三种情况对他进行二分搜索 
                这里 我们的返回值是 当前找到的这个根节点 他的value值所在的地址 
                清楚了这个 我们就可以按照先前的思路 对他进行递归查找了 
            */</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> node<span class="token operator">-</span><span class="token operator">></span>key <span class="token punctuation">)</span> <span class="token keyword">return</span>  <span class="token operator">&amp;</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>value<span class="token punctuation">)</span> <span class="token punctuation">;</span>

            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> key <span class="token operator">&lt;</span> node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">else</span> <span class="token keyword">return</span>  <span class="token function">search</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span>

        <span class="token keyword">private</span> <span class="token operator">:</span>  

        Value<span class="token operator">*</span> <span class="token function">search</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>root <span class="token punctuation">,</span>key <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS(深度优先搜索)"></a>DFS(深度优先搜索)</h4><ul>
<li><p>DFS 深度优先搜索 顾名思义 他是一个树一个树  从根节点 一至到叶子节点的遍历 </p>
</li>
<li><p>我么们来讲三种遍历方法的共同点和不同点 大家可以先草率的看一下代码 就会发现 出奇的相似 只是改了一下名称和顺序 </p>
</li>
<li><p>对 这就是三个顺序的遍历 其实他们走过的路径是一模一样的  </p>
</li>
<li><p>他的思想就是 只有节点不为空 他就一直向着他的孩子节点递归 直到为空返回 返回回来 他又会向着另一边深入去递归 直到找到叶子节点为空 </p>
</li>
<li><p>每一个节点都会被路过三次 转个圈也算三次 (看似三次) 那么这三种遍历方法区别就在于 第几次遍历他的时候 打印他的值 。</p>
</li>
</ul>
<h5 id="前序遍历-preOrder"><a href="#前序遍历-preOrder" class="headerlink" title="前序遍历 preOrder"></a>前序遍历 preOrder</h5><pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span> 

        <span class="token comment" spellcheck="true">//在node为根的树中 对他进行前序遍历</span>
        <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                cout<span class="token operator">&lt;&lt;</span>node<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
                <span class="token function">preOrder</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">preOrder</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="中序遍历-inOrder"><a href="#中序遍历-inOrder" class="headerlink" title="中序遍历 inOrder"></a>中序遍历 inOrder</h5><pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span> 

        <span class="token comment" spellcheck="true">//在node为根的树中 对他进行中序遍历</span>
        <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                cout<span class="token operator">&lt;&lt;</span>node<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
                <span class="token function">inOrder</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="后序遍历-postOrder"><a href="#后序遍历-postOrder" class="headerlink" title="后序遍历 postOrder"></a>后序遍历 postOrder</h5><pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span> 

        <span class="token comment" spellcheck="true">//在node为根的树中 对他进行后序遍历</span>
        <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">postOrder</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">postOrder</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
                cout<span class="token operator">&lt;&lt;</span>node<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>如何去理解三种遍历方法 我也给出了 一种简单的方法去记 。</p>
</li>
<li><p>每一个节点都被箭头指向三次 第几次被指 就是什么遍历 </p>
</li>
<li><p>红箭头指向<br><img src="http://onh0umlhz.bkt.clouddn.com/miccall%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" alt="前"></p>
</li>
<li>绿箭头指向<br><img src="http://onh0umlhz.bkt.clouddn.com/miccall%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" alt="中"></li>
<li>蓝箭头指向<br><img src="http://onh0umlhz.bkt.clouddn.com/miccall%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" alt="后"></li>
</ul>
<h4 id="BSF-广度优先搜索-levelOrder-层次遍历"><a href="#BSF-广度优先搜索-levelOrder-层次遍历" class="headerlink" title="BSF (广度优先搜索) levelOrder 层次遍历"></a>BSF (广度优先搜索) levelOrder 层次遍历</h4><ul>
<li><p>层次遍历对比与DFS的重要性和复杂性来说要低很多 但也是非常重要的思想 </p>
</li>
<li><p>他是层次遍历 也就是所 他是一级一级遍历的 所以我们得想办法记录不同的根节点 </p>
</li>
<li><p>很容易我们想到 可以用队列的方式来暂时存取我们记录的层的节点 </p>
</li>
<li><p>当一层遍历结束 我们从队列的最前面取出一个节点 对他的子节点进行入队 这样 第一层结束后 紧接着的就是第二层的遍历 </p>
</li>
<li><p>以此类推 。</p>
</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span>

        <span class="token comment" spellcheck="true">//在node为根的树中 对他进行层序遍历</span>
        <span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>root<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            queue<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span> q <span class="token punctuation">;</span> 
            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//当队列不为空我们对他进行遍历 </span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                Node <span class="token operator">*</span>node <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//取出一个节点 </span>
                q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//让这个点处队 </span>

                cout<span class="token operator">&lt;&lt;</span>node<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 打印这个点 </span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果她有左子树 那么把他入队 </span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//同时 如果她有右子树 也把他入队 </span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>


        <span class="token keyword">public</span> <span class="token operator">:</span> 

        <span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">levelOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="寻找最大值与最小值"><a href="#寻找最大值与最小值" class="headerlink" title="寻找最大值与最小值"></a>寻找最大值与最小值</h4><ul>
<li>如果你前面都非常理解了 就会很容易的知道 最大值 就在最右的子节点 相同的 最小值 就在最左的字节点 </li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">
        <span class="token keyword">private</span> <span class="token operator">:</span> 

        <span class="token comment" spellcheck="true">//寻找最小值 以node为根的树找最小值 返回最小值节点 </span>
        Node <span class="token operator">*</span> <span class="token function">minimum</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> node <span class="token punctuation">;</span>

            <span class="token keyword">return</span> <span class="token function">minimum</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 一直向左子树寻找 </span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">//寻找最大值 以node为根的树找最大值 返回最大值节点</span>
         Node <span class="token operator">*</span> <span class="token function">maximum</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> node <span class="token punctuation">;</span>

            <span class="token keyword">return</span> <span class="token function">maximum</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//向右子树寻找 </span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        Key <span class="token function">minimum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">assert</span><span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            Node<span class="token operator">*</span> minNode <span class="token operator">=</span> <span class="token function">minimum</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token keyword">return</span> minNode<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>

        Key <span class="token function">maximum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">assert</span><span class="token punctuation">(</span>count <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
            Node <span class="token operator">*</span>maxNode <span class="token operator">=</span> <span class="token function">minimum</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> maxNode<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="移除最大值与最小值"><a href="#移除最大值与最小值" class="headerlink" title="移除最大值与最小值"></a>移除最大值与最小值</h4><ul>
<li><p>移除最小值有两种情况 一种是他没有右子树 那么问题就简单了 我们可以直接移除这个值 </p>
</li>
<li><p>但是另一种情况 他有右子树 我们怎样处理呢 其实也简单 。他的右子树虽然都比他本身大 但是肯定比他的父亲节点小 ，所以我们只要简单的 把右子树的节点移过来 代替删除的最小节点 ，让他成为最小值父亲的左子树 ，就可以了。</p>
</li>
<li><p>类似的情况 我们删除他的最大值也是这样 如果他有左孩子的话 因为他的左孩子依然是一个二分搜索树 。也可以直接把他移过来就可以了 。</p>
</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> ：

        <span class="token comment" spellcheck="true">//移除最小值 删除以node为根的BST中的最小值 返回删除之后新的根 </span>
        Node <span class="token operator">*</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node <span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果左子树为空 那么我们找到了这个最小值 </span>
            <span class="token punctuation">{</span>
                Node <span class="token operator">*</span> rightNode <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right <span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//看看右子树是否存在 为NULL也可以 </span>
                <span class="token keyword">delete</span> node <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//删除 node </span>
                count<span class="token operator">--</span> <span class="token punctuation">;</span>      
                <span class="token keyword">return</span> rightNode <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  </span>
            <span class="token punctuation">}</span>
            node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//继续寻找 </span>
            <span class="token keyword">return</span>  node <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回这个根 </span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">//移除最大值 同理 </span>
        Node <span class="token operator">*</span> <span class="token function">removeMax</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node <span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                Node <span class="token operator">*</span> leftNode <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left <span class="token punctuation">;</span>
                <span class="token keyword">delete</span> node <span class="token punctuation">;</span>
                count<span class="token operator">--</span> <span class="token punctuation">;</span>
                <span class="token keyword">return</span> leftNode <span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span>  node <span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> ： 
        <span class="token keyword">void</span> <span class="token function">removeMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果根不会空 </span>
                root <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span> root <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">void</span> <span class="token function">removeMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
                root <span class="token operator">=</span> <span class="token function">removeMax</span><span class="token punctuation">(</span> root <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="移除任意一个值"><a href="#移除任意一个值" class="headerlink" title="移除任意一个值"></a>移除任意一个值</h4><ul>
<li><p>1.为什么要讲删除最大值和最小值呢 因为最坏的情况下 最小值只有右孩子 最大值只有左孩子 这为我们删除任意值奠定了基础。因为这种方法可以删除任意一个只有一个孩子的节点。</p>
</li>
<li><p>2.最难的情况可想而知了 删除一个任意一个节点 他可以有左右两个子树 。</p>
</li>
<li><p>3.假设我们删除一个节点 我们设他为 d  据我们的经验 删除这个节点 ，必定要找一个值来代替他 ，那么是从他的左右孩子中找吗 ，那不一定 我们想 应该是找一个最接近他的值才可以 但是我们也知道 以d为根的子树 右边得找一个最小值 左边得找一个最大值 才能最接近d 。</p>
</li>
<li><p>4.那我们就假设是 s 是d 的取代值 那么 s = min(d.right)  </p>
</li>
<li><p>5.找到s之后呢 我们先拿出来s节点 ，然后就要用我们之前的方法 删除d.right的最小值 也就是s节点，  然后把拿出来的s节点的右子树指向这个d.right。 然后 s.left = d.left 这个左子树不能丢 也得找到 。</p>
</li>
<li><p>6.这样就就绪了 那么现在就可以放心的删除d这个节点了。 这样 s 就是新的子树的根 </p>
</li>
<li><p>其实，我们也可以找 s = max(d.left) 同样也是可以的 这里我们就不写了 </p>
</li>
<li><p>O(logn)</p>
</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token keyword">private</span> <span class="token operator">:</span>

        <span class="token comment" spellcheck="true">//删除以node为根 树中键值为key的节点</span>
        <span class="token comment" spellcheck="true">//返回一个删除节点后的新的 根</span>

        Node<span class="token operator">*</span> <span class="token function">remove</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> Key key<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//找不到这个节点 </span>
                <span class="token keyword">return</span>  <span class="token constant">NULL</span><span class="token punctuation">;</span> 
            <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//二分搜索</span>
                node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> 
                <span class="token keyword">return</span> node<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">></span>node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//二分搜索</span>
                node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> node<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span><span class="token punctuation">{</span>

                <span class="token comment" spellcheck="true">// 找到了这个节点node </span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//只有右孩子</span>
                <span class="token punctuation">{</span>
                    Node <span class="token operator">*</span> rightnode <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right <span class="token punctuation">;</span>
                    <span class="token keyword">delete</span> node <span class="token punctuation">;</span>
                    count <span class="token operator">--</span> <span class="token punctuation">;</span>
                    <span class="token keyword">return</span> rightnode <span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//只有左 孩子</span>
                <span class="token punctuation">{</span>
                    Node <span class="token operator">*</span> leftnode <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left <span class="token punctuation">;</span>
                    <span class="token keyword">delete</span> node <span class="token punctuation">;</span>
                    count <span class="token operator">--</span> <span class="token punctuation">;</span>
                    <span class="token keyword">return</span> leftnode <span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment" spellcheck="true">// 有两个孩子 </span>

                <span class="token comment" spellcheck="true">//Node * delnode = node ;  先保存这个节点(其实没必要)</span>

                Node <span class="token operator">*</span> successor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token function">minimum</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
                <span class="token comment" spellcheck="true">// node的最小值所在的节点 就是我们要拿来替换的节点 这里我们为了避免指针指向失败的问题 重新开一个空间节点 </span>

                count<span class="token operator">++</span> <span class="token punctuation">;</span>

                successor<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">removeMin</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  
                <span class="token comment" spellcheck="true">//removeMin的时候 会把successor delete掉 导致successor失效 所以我们必须开一个新的节点来存储这个值 </span>

                successor<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left <span class="token punctuation">;</span>  

                <span class="token comment" spellcheck="true">//删除这个节点  </span>
                <span class="token keyword">delete</span> node<span class="token punctuation">;</span>
                count <span class="token operator">--</span> <span class="token punctuation">;</span>
                <span class="token keyword">return</span> successor <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//新的节点 </span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token operator">:</span>

        <span class="token comment" spellcheck="true">//删除键值为key的节点 </span>
        <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Key key<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            root <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul>
<li>有了前面一大片的铺垫 相信这个析构函数就很好解决了 我们通过对他进行后序遍历 并把他一个一个销毁</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp">
        <span class="token keyword">private</span> <span class="token operator">:</span>
        <span class="token comment" spellcheck="true">//在node为根的树中 对他进行后序遍历 并把他销毁</span>
        <span class="token keyword">void</span> <span class="token function">destory</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">destory</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">destory</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">delete</span> node<span class="token punctuation">;</span>
                count<span class="token operator">--</span> <span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token operator">:</span>
        <span class="token operator">~</span><span class="token function">BinarySearchTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">destory</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="其他的一些知识"><a href="#其他的一些知识" class="headerlink" title="其他的一些知识"></a>其他的一些知识</h3><ul>
<li>排序</li>
<li>最大最小值 </li>
<li>前驱后继 </li>
<li>floor和ceil<br>floor表示 ： 如果树中没有key 那么 就找最接近这个值，且小于这个值的key所对应的value<br>ceil正好相反 如果树中没有key 那么 就找最接近这个值，且大于这个值的key所对应的value</li>
<li>rank和select<br>rank ： 某一个key在一个树中排名第几<br>select ： 在一个树中 排名第n的元数是谁</li>
<li>支持重复元素的二分搜索 </li>
</ul>
<h3 id="BST的局限性"><a href="#BST的局限性" class="headerlink" title="BST的局限性"></a>BST的局限性</h3><ul>
<li><p>同样的数据 ，可能对应不同的BST 一个顺序的存入方式 可以使得一个树退化成一个链表 。可能导致比顺序查找都慢 (递归的时间消耗和两个指针的搜索)</p>
</li>
<li><p>解决方法 ： 平衡二叉树 __红黑树,2-3树,AVL树,Splay树等 使二叉树不能退化成链表</p>
</li>
<li><p>平衡二叉树和堆的结合__ Treap   </p>
</li>
</ul>
<h3 id="其他递归问题"><a href="#其他递归问题" class="headerlink" title="其他递归问题"></a>其他递归问题</h3><ul>
<li>归并排序 </li>
<li>快速排序 </li>
<li>搜索问题</li>
<li>决策树 </li>
<li>8数码 </li>
<li>8皇后 </li>
<li>KD树 区间树 哈夫曼树 </li>
</ul>

             </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://miccall.tech/2017/04/27/algorithm/BST/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://miccall.tech/2017/04/27/algorithm/BST/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2017总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
